Trabalho 1 de Inteligência Artificial - 2023
GUSTAVO VALENTE NUNES GRR20182557

Introdução:
  O objetivo do trabalho é implementar um algoritmo que resolva um jogo chamado floodit utilizando algum algoritmo inteligente, em nossa estratégia foi utilizado um algoritmo chamado A* (a star).


Forma de executar:
  make
  ./floodit < arquivo.in > arquivo.out

Estrutura de diretórios: 
  docs: Documentação gerada a partir do doxygen.
    -> Para gerar a documentação é necessário fazer um make docs.

  src: Contém todos os arquivos do tipo *.c.
    flood_it.c: Contém a parte principal do código, onde está implementando o A*.
    io.c: Cuida da parte de input e saída de dados. 
    utils.c: Cuida da alocação de matriz, e algumas outras coisas a mais. 
    queue.c: Implementação de uma api de fila, insere, remove, calcula tamanho e imprime a fila. 
    main.c: Arquivo que contém a main do código. 
    error.h: Trativa de erros.
     
  includes: Contém todos os arquivos do tipo *.h
    flood_it.h: Prototipo das funções do flood_it.c.
    io.h: Prototipo das funções do io.c.
    utils.h: Prototipo das funções do utils.c.
    queue.h: Prototipo das funções do queue.c.
    error.h: Prototipo das funções do error.c.

  build: Contém todos os arquivos objetos após a compilação.
  tests: Contém todos os arquivos de testes utilizados no código.

Estratégia de desenvolvimento:
    Recebemos um arquivo de entrada na entrada padrão, e lemos a primeira linha que seriam as dimensões e a quantidade de cores que o tabuleiro terá. Pegamos essas dimensões e criamos uma matriz. Agora que temos uma matriz criada, como se fosse o tabuleiro, podemos começar a implementar o A*.
    Logo no início da função a_star(), criamos uma fila chamada "visisted_nodes", que vai nos dizer quais foram os pontos do tabuleiro que já estão conectados com o início. E para encontrar todo o conjunto, é utilizado um algoritmo chamado flood fill. 
    Assim que temos todo o conjunto na fila, podemos procurar os elementos que estão em suas bordas, que serão os possíveis próximos passos. Para isso, temos uma fila de "possible_next" que indica os elementos que estão nas bordas dos pontos já visitados, essa borda é recursiva de forma que se tivermos uma borda de valor 2 e o vizinho do 2 desta borda também for 2, é considerado esse vizinho do vizinho como borda também e é adicionado esse valor ao "possible_next" junto com a própria borda em si. 
    Como temos essa lista de possíveis próximos nodos, só precisamos calcular a heurística naquele ponto com seu estado atual. Como é possível jogar pelas quatro pontas do tabuleiro, a estratégia utilizada para resolver o jogo é a seguinte:
      1. Furar o tabuleiro do quadrante A ao quadrante C. 
      2. Após chegar no quadrante C, a estratégia é tentar criar uma ponta no quadrante B ou D, o que vier primeiro. Porém, a ideia é tentar mirar no quadrante B primeiro.
      3. E para finalizar, é feito uma ponta para o D. Porém, caso o D tenha sido perfurado antes do B, então nesse caso a última ponta seria para o B. 
        Nota: Em relação aos pontos 2 e 3, na estratégia a ordem é A->C->B->D, porém em tabuleiros pequenos, pode ser que aconteça do D ser perfurado primeiro que o B e se isso acontecer, só inverte a ordem para A->C->D->B, porém a estratégia e heurística contínua sendo a mesma.
      4. Então em partes, o jogo fica A->C->B->D e após chegar no D o tabuleiro está quase sendo finalizado não é mais mudado a heurística, deixa apenas seguir o fluxo até terminar.

Heuristica e custo:
  g(n): Temos dois casos, no caso inicial quando se abre o jogo, o g(n) é a soma dos índices para indicar o quão longe o quadrante A está do quadrante C.
        Depois que se chega no quadrante C, é feito a mesma coisa, só que o g(n) muda para fazer a heurística apontar para o quadrante B e depois para o quadrante D. 

  h(n): A nossa heurística é uma linha reta na diagonal, dependendo do ponto pode ser 
        uma linha reta mesmo. É utilizado o teorema de Pitágoras para calcular essa distância. 
        Conforme o jogo vai se desenvolvendo, é mudado para onde a heurística é apontada, dependendo de como o jogo está em andamento, pode apontar para o quadrante B ou para o D.

Estruturas utilizadas:
 Temos uma estrutura genérica de fila:

    typedef struct queue_t {
      struct queue_t *prev; // aponta para o elemento anterior na fila
      struct queue_t *next; // aponta para o elemento seguinte na fila
    } queue_t;

    Essa estrutura nos permite criar outra struct fila qualquer, com qualquer coisa dentro dela, e sempre que eu for fazer alguma chamada para a API da fila, faço um casting para essa struct acima, conseguindo alocar os elementos sem problema. 

Estrutura utilizada para o "visisted_nodes" e "possible_next":

    typedef struct queue_state_t {
      struct queue_state_t *prev;
      struct queue_state_t *next;
      struct state_t st; -> Indica o elemento que está nesse nodo da fila. 
    } queue_state_t;

Utilizo uma estrutura de fila, e sempre que vou fazer uma inserção ou remoção, tenho que fazer o casting para a estrutura de cima (queue_t).

Estrutura que a matriz aloca, para cada elemento dela:
  Temos basicamente uma matriz: m[n][m] com o tipo state_t.

    typedef struct state_t {
      int value;        -> Indica a cor do elemento
      int g_n;          -> Indica seu custo do desde a raiz. 
      int lin;          -> Indica qual linha da matriz ele pertence
      int col;          -> Indica qual coluna da matriz ele pertence
      int f_n;          -> Indica o resultado do g(n) + h(n)
      int visited;      -> Indica se esse nodo já pertence ao "visited_nodes"
      int h_n;          -> Resultado do pitágoras. 
      int id;           -> Indica o id do elemento
      int in_board;     -> Indica se ele já pertence ao "possible_next"
      int quadrant;     -> Indica o quadrante no momento.
    } state_t;

Estrutura utilizada para armazenar os resultados de cada passo do jogo:
    typedef struct result
    {
      int result;
      int quadrant;
    } result_t;
